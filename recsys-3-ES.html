<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>  Sistemas recomendadores, parte 3 | On the shoulders of giants
</title>
  <link rel="canonical" href="/recsys-3-ES.html">

    <link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#333333">

  <link rel="stylesheet" href="/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="/theme/css/font-awesome.min.css">
  <link rel="stylesheet" href="/theme/css/pygments/monokai.min.css">
  <link rel="stylesheet" href="/theme/css/theme.css">

  
  <meta name="description" content="Tercera parte de sistemas recomendadores">


</head>

<body>
  <header class="header">
    <div class="container">
<div class="row">
    <div class="col-sm-4">
      <a href="/">
        <img class="img-fluid rounded" src=/images/profile.png width=400 height=400 alt="On the shoulders of giants">
      </a>
    </div>
  <div class="col-sm-8">
    <h1 class="title"><a href="/">On the shoulders of giants</a></h1>
      <p class="text-muted">Diego Quintana's blog</p>
      <ul class="list-inline">
            <li class="list-inline-item"><a href="/pages/about.html">About</a></li>
            <li class="list-inline-item"><a href="/pages/contact-EN.html">Contact</a></li>
            <li class="list-inline-item"><a href="/pages/now-EN.html">Now</a></li>
            <li class=" list-inline-item text-muted">|</li>
          <li class="list-inline-item"><a class="fa fa-github" href="https://github.com/diegoquintanav" target="_blank"></a></li>
          <li class="list-inline-item"><a class="fa fa-linkedin" href="https://www.linkedin.com/in/diego-quintana-valenzuela/" target="_blank"></a></li>
          <li class="list-inline-item"><a class="fa fa-stack-overflow" href="https://stackoverflow.com/users/5819113/bluesmonk" target="_blank"></a></li>
          <li class="list-inline-item"><a class="fa fa-envelope" href="mailto:daquintanav@gmail.com" target="_blank"></a></li>
      </ul>
  </div>
</div>    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>  Sistemas recomendadores, parte 3
</h1>
      <hr>
  <article class="article">
    <header>
      <ul class="list-inline">
        <li class="list-inline-item text-muted" title="2017-11-01T18:01:00-06:00">
          <i class="fa fa-clock-o"></i>
          mié 01 noviembre 2017
        </li>
        <li class="list-inline-item">
          <i class="fa fa-folder-open-o"></i>
          <a href="/category/recommender-systems.html">recommender systems</a>
        </li>
          <li class="list-inline-item">
            <i class="fa fa-files-o"></i>
              <a href="/tag/recommender-systems.html">#recommender systems</a>,               <a href="/tag/recsys.html">#recsys</a>          </li>
      </ul>
    </header>
    <div class="content">
      <h1><em>previously</em></h1>
<p>En la <a href="/recsys-2-ES.html">parte 2</a> se vieron algunas clasificaciones de <em>SR</em>, y mencionamos aquellos basados en <em>memoria</em> y basados en <em>modelos</em>. </p>
<p>Otra clasificación que se mencionó se refiere a <em>SR</em> basados en <strong>contenido</strong>, o <em>content-based</em>.</p>
<h1>Sistemas recomendadores basados en contenido</h1>
<p>Existen elementos que son cuantificables de manera directa, i.e.</p>
<ol>
<li>Popularidad</li>
<li>Género</li>
<li>Director</li>
<li>Ratings</li>
</ol>
<p>El filtrado colaborativo permite abordar estos elementos de manera directa. Se vio sin embargo que estos <em>SR</em> sufren de algunos problemas debido a la naturaleza <em>poco densa</em> de los datos en el contexto de recomendación, así como el <em>new item problem</em>, entre otros.</p>
<p>Podemos decir también que hay otros elementos que no son cuantificables directamente y dependen de otras cosas, por ejemplo aquellos elementos relacionados al contexto, tales como:</p>
<ol>
<li>Título de una película</li>
<li>Descripción de un evento</li>
</ol>
<p>En teoría, usando análisis de contenido, es posible generar recomendaciones considerando que existen descripciones suficientes. </p>
<p>Algunos aspectos del análisis de contenido pueden ser</p>
<ol>
<li>Análisis de texto</li>
<li>Análisis del perfil de usuario</li>
<li>Filtrado de contenido</li>
</ol>
<p>Este tipo de <em>SR</em> presentan la ventaja de que es más fácil explicar las recomendaciones en función del mismo contenido.</p>
<p>Sin embargo, dado que las recomendaciones dependen del análisis de contenido de las recomendaciones previas, puede ocurrir lo que se conoce como una burbuja de información o <em>filter bubble</em>. Esta situación produce que las nuevas recomendaciones terminen siendo muy similares a lo ya consumido. </p>
<p>Por ejemplo, si me gusta Harry Potter, puede ocurrir que el <em>SR</em> sólo pueda recomendarme libros de Harry Potter y no de la narrativa fantástica en general, lo que dependiendo del caso, puede ser un resultado indeseado.</p>
<h1>¿Cómo podemos analizar el contenido?</h1>
<p>El aspecto más importante de este tipo de <em>SR</em> es su dependencia de la ?<em>representación</em> del contenido. </p>
<p>De manera más general en otras áreas esto se conoce como <em>information retrieval</em>, y tiene que ver en cómo se extrae y representa información de los datos.</p>
<p>En ese sentido, la forma más simple es la de analizar el texto en las descripciones de los ítems que forman parte del dataset.</p>
<h2>Representación vectorial de texto</h2>
<p>La primera representación que se puede hacer de un texto es a través de lo que se conoce como <a href="https://machinelearningmastery.com/gentle-introduction-bag-words-model/"><em>bag of words</em></a>, donde las palabras se comparan con un diccionario o <em>corpus</em>, y se representan como el número de repeticiones que esa palabra aparece en el texto.</p>
<p>Esto a su vez permite otras representaciones, una es VSM o <em>Vector space model</em>, el cual se trata de vectorizar términos en función de su aparición en una <strong>familia</strong> </p>
<p>Un ejemplo se puede ver en la siguiente imagen, donde la palabra <em>likes</em> se representa como la frecuencia en la que la palabra aparece en tres documentos distintos:</p>
<p><img alt="vsm1" src="/images/vsm1.png" title="vsm1" /></p>
<p>Usando un procedimiento similar, es posible también representar un <strong>documento</strong> como un vector, donde cada elemento del vector es la frecuencia de cada palabra de un corpus que aparece en el documento.</p>
<div class="math">$$
v = [f_{1},f_{2},...,f_{n}]
$$</div>
<p>donde <span class="math">\(f_{i}\)</span> es la frecuencia de cada palabra. Un vector de palabras o diccionario o <em>corpus</em>, para el caso del castellano por ejemplo, es de aproximadamente 60000 palabras. </p>
<p>La ventaja de esta representación es que al tratarse de vectores, estos tienen propiedades geométricas que permiten establecer comparaciones entre ellos.</p>
<h3>Regularización de texto</h3>
<p>La frecuencia de las palabras por sí sola en un documento no ayuda necesariamente a establecer similitudes, por ejemplo es muy posible encontrar muchas veces en un documento las palabras <em>él, ella, qué, etcétera</em>, lo que no ayudan mucho. Dos documentos no son necesariamente iguales si tienen relativamente la misma cantidad de veces la palabra <em>qué</em>.</p>
<p>Es por esto que se desarrollan métodos de regularización, el primero es normalizar la frecuencia de los términos, a través de lo que se conoce como TF o <em>term frequency</em>. En otras palabras, esto significa:</p>
<div class="math">$$
\mbox{TF}(\mbox{palabra},\mbox{documento}) = \frac{\mbox{veces que aparece la palabra en el documento}}{\mbox{cantidad máxima de veces que aparece la palabra en todos los documentos}}
$$</div>
<p>Además, si se considera nuevamente como ejemplo la palabra <em>qué</em>, esta no es más importante en un documento si aparece digamos, un 70% de las veces. 
Queremos entonces detectar otras palabras que aparecen con menor frecuencia. Para incorporar esto se usan logaritmos:</p>
<div class="math">$$
\left\{
    \begin{aligned}
    &amp; 1+\log_{10} \mbox{TF}_{p,d} &amp; \mbox{TF}_{p,d} \ge 1\\
    &amp; 0 &amp; \mbox{TF}_{p,d} = 0\\
    \end{aligned}
\right.
$$</div>
<p>Finalmente combinando ambos elementos, es posible obtener una representación estable a través de TF-IDF</p>
<div class="math">$$
\mbox{TF-IDF}{p,d} = \mbox{TF}{p,d} \times \log \frac{N}{n_{p}}
$$</div>
<p>De aquí</p>
<ul>
<li><span class="math">\(N\)</span> es la cantidad de documentos del dataset</li>
<li><span class="math">\(n_{p}\)</span> es la cantidad de documentos donde aparece la palabra</li>
<li>El valor de <span class="math">\(\log(N/n_{p})\)</span> tiende a cero cuando la palabra aparece en muchos documentos (por ejemplo artículos, preposiciones, etc.)</li>
</ul>
<h2>Representación semántica del contenido y la web semántica</h2>
<p>El texto representado como <em>bag of words</em> carece de sentido contextual. El contexto en sí mismo añade una nueva capa al análisis de texto, y entre las formas de incorporarlo se pueden usar <em>ontologías</em>.</p>
<p>Al respecto, la idea de una <a href="https://en.wikipedia.org/wiki/Semantic_Web">web semántica</a> intenta modelar los contenidos de internet a través de estructuras ontológicas estandarizadas llamadas <a href="https://en.wikipedia.org/wiki/Resource_Description_Framework">RDF</a></p>
<h2>Métricas de similitud</h2>
<p>Como vimos anteriormente, la vectorización de documentos permite operaciones entre vectores, los cuales tienen un sentido geométrico y por lo tanto permiten establecer métricas de distancia entre ellos. </p>
<p>Las más conocidas ya se han visto y corresponden a:</p>
<ul>
<li>Distancia euclidiana</li>
<li>Distancia coseno</li>
</ul>
<p>Sin embargo, un <em>corpus</em> en general es de alta dimensionalidad, (60000 palabras para el castellano, por ejemplo) y aquí <strong>la maldición de la dimensionalidad</strong> (<em>curse of dimensionality</em>) se presenta nuevamente como un problema. </p>
<p>Al respecto, podemos normalizar los vectores y obtener mejores resultados con la distancia coseno, y otras métricas diseñadas para este problema como por ejemplo <a href="https://dl.acm.org/citation.cfm?doid=1639714.1639757">OKAPI BM25</a></p>
<h2>Manejo de sinónimos</h2>
<p>Puede ocurrir que dos palabras son iguales pero tienen distintos significados, lo que complica las comparaciones. Al respecto existen técnicas como</p>
<ul>
<li><em>Latent semantic Indexing</em></li>
<li><em>Latent dirichlet allocation</em></li>
</ul>
<h2>Técnicas de procesamiento adicionales</h2>
<p>El análisis de texto presenta otro tipo de problemas, pudiendo encontrarse</p>
<ul>
<li>palabras mal escritas</li>
<li>calidad del texto</li>
<li>redacción pobre</li>
</ul>
<p>Para esto se pueden usar algunas técnicas auxiliares, como por ejemplo</p>
<ul>
<li>Normalización: pasar todo a minúsculas o mayúsculas</li>
<li>Tokenización: Dividir una oración en unidades o <em>tokens</em>. La tokenización depende de cada implementación.</li>
<li><em>Stemming</em>: Tomar la raíz (<em>stem</em>) de las palabras que compartan una raíz semántica (por ejemplo <em>auto</em> en <em>Automovilismo</em> y <em>Autopista</em>)</li>
<li><em>Porter</em>: <em>Stem</em> de las primeras letras que se repiten.</li>
<li><em>Krovetz</em>: <em>Stem</em>, pero asociada a una palabra existente.</li>
<li><em>Lemmatization</em>: Una variante de <em>stemming</em> que incorpora el análisis morfológico del texto. Ver más información <a href="https://nlp.stanford.edu/IR-book/html/htmledition/stemming-and-lemmatization-1.html">aquí</a></li>
</ul>
<h2>En python</h2>
<p>En python existen dos librerías importantes para esto,</p>
<ul>
<li><a href="www.nltk.org">NLTK</a></li>
<li><a href="https://spacy.io">Spacy</a></li>
</ul>
<p>Aparentemente NLTK tiene más funcionalidades pero su diseño no permite escalar de
la mejor manera. Spacy, al contrario, presenta menos funcionalidades (aunque suficientes) y utiliza <em>defaults</em> aptos para su uso en la industria.</p>
<p>En inglés se dice que una librería es <em>opinionated</em> cuando impone ciertos patrones y procedimientos con base en la experiencia de los creadores de la herramienta. Un ejemplo de esto es <em>ruby on rails</em> o <em>django</em> para desarrollo web.</p>
<p>Esto se podría traducir como un diseño <em>dogmático</em>, aunque esta traducción no me gusta del todo.</p>
<h2>A continuación</h2>
<p>En la parte 4 se verán
<!-- En la <a href="/drafts/recsys-4.html">parte 4</a> se verán --></p>
<ul>
<li>Sistemas recomendadores híbridos</li>
<li>Métricas de calidad en sistemas recomendadores</li>
</ul>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </div>
  </article>
    </div>
  </div>

  <footer class="footer">
    <div class="container">
<div class="row">
  <ul class="col-sm-6 list-inline">
    <li class="list-inline-item"><a href="/archives.html">Archives</a></li>
    <li class="list-inline-item"><a href="/categories.html">Categories</a></li>
      <li class="list-inline-item"><a href="/tags.html">Tags</a></li>
  </ul>
  <p class="col-sm-6 text-sm-right text-muted">
    Generated by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
    / <a href="https://github.com/nairobilug/pelican-alchemy" target="_blank">&#x2728;</a>
  </p>
</div>    </div>
  </footer>
</body>

</html>